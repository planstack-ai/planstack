# 機能

Plan Stack の主要な機能と能力について説明します。

## コア機能

### 1. Plan-First 開発

すべての実装は計画から始まります。

```
ユーザーリクエスト → 調査 → 計画 → 承認 → 実行 → レビュー
```

**メリット:**
- コードを書く前にアプローチを合意
- 認識のズレによる手戻りを削減
- すべての変更に対してレビュー可能な成果物を作成

### 2. 知識の蓄積

計画書は `docs/plans/` に蓄積され、組織的な知識を形成します。

```
docs/plans/
├── 20250115_user_authentication.md
├── 20250120_payment_integration.md
├── 20250201_api_rate_limiting.md
└── completed/
    ├── 20241218_staff_message.md
    └── 20241220_signup_profile.md
```

**メリット:**
- 新しい実装は過去の決定を参照できる
- 蓄積されたコンテキストでオンボーディングが加速
- AI アシスタントが履歴知識を活用

### 3. コンテキスト認識型 AI アシスタンス

AI エージェントは、生のコードベースではなく、キュレートされたコンテキストから始まります。

| 従来のアプローチ | Plan Stack アプローチ |
|---------------------|---------------------|
| リポジトリ全体をダンプ | 関連する計画書を読み込む |
| ゼロから開始 | 過去の決定から開始 |
| `/clear` でコンテキスト喪失 | 計画書から復元 |

**メリット:**
- より高品質な AI 出力
- 一貫した実装パターン
- 決定の理由が保持される

### 4. 構造化されたレビュープロセス

レビューは計画と実装を比較し、ドリフトを検出します。

**レビューチェックリスト:**
- [ ] 実装が計画の意図と一致している
- [ ] 逸脱は理由とともに文書化されている
- [ ] 教訓が記録されている

**メリット:**
- コードだけでなく意図にフォーカスしたレビュー
- ドリフト追跡でサイレントな乖離を防止
- フィードバックによる継続的改善

## ワークフロー機能

### 調査フェーズ

新しい作業を始める前に過去の計画書を検索します。

```bash
# 関連する実装を検索
ls docs/plans/ | grep authentication
```

**探すべきもの:**
- 類似の機能実装
- 適用可能なアーキテクチャ決定
- 機能したパターン（または機能しなかったパターン）

### 計画フェーズ

構造化された実装計画を作成します。

**計画書に含めるもの:**
1. タスクの概要とコンテキスト
2. 調査結果
3. 実装アプローチ
4. 修正するファイル
5. 検証計画

一貫性のために[計画テンプレート](../templates/plan-template.md)を使用してください。

### 実行フェーズ

計画をガイドとして実装します。

**ベストプラクティス:**
- 承認されたアプローチに従う
- 逸脱が発生したら文書化する
- 変更を計画の範囲内に保つ

### レビューフェーズ

計画と実際の実装を比較します。

**レビューの観点:**
- 完全性: すべて実装されたか？
- ドリフト: 計画から何が変わったか？
- 品質: コードは基準を満たしているか？
- 教訓: 何を覚えておくべきか？

## チーム機能

### Human-in-the-Loop

承認ゲートが人間の監督を確保します。

```
計画作成 → 人間レビュー → 承認/却下 → 実行
```

**コントロールポイント:**
- 実装前の計画承認
- 実装後のコードレビュー
- マージ前のドリフトレビュー

### オンボーディングの加速

新メンバーは計画書を書くことで学びます。

**オンボーディングワークフロー:**
1. AI アシスタンスで担当エリアを調査
2. 小さな修正の計画書を書く
3. シニアがコード前に意図をレビュー
4. 承認後に実装
5. レビューで教訓を記録

**結果:** 質問が文書化された回答になる。

### 非同期コラボレーション

計画書は非同期レビューと引き継ぎを可能にします。

**ユースケース:**
- 異なるタイムゾーンでの計画レビュー
- 別の開発者への実装引き継ぎ
- 中断後の作業再開

## 統合機能

### GitHub 統合

計画書は GitHub ワークフローと統合されます。

- プルリクエストに計画書を含める
- コミットメッセージで計画書を参照
- Issue を実装計画にリンク

### CI/CD 統合

Claude GitHub Actions による自動レビュー。

```yaml
# ワークフロー例
on: pull_request
jobs:
  review:
    - 実装と計画を比較
    - ドリフトを人間レビュー用にフラグ
    - レビューサマリーを生成
```

### IDE 統合

Claude Code と連携してシームレスな体験を。

**キーショートカット:**
- `Shift+Tab` 2回: Plan Mode に入る
- `/clear`: コンテキストをリセット
- 再開: 「計画を読んで続けて」

## 高度な機能

### 計画書のプロモーション

重要な計画書を永続的なドキュメントに昇格させます。

| 昇格先 | 基準 |
|-------------|----------|
| `architecture/` | 3つ以上の機能に影響するか、システム境界を定義する |
| `features/` | 複数の将来の計画で参照される |

### 既存プロジェクトへの導入

方法論ではなく、問題から始めます。

```
監査 → トリアージ → 計画 → 実装 → レビュー
```

1. AI がコードベースを分析して問題を特定
2. 発見を GitHub Issue に変換
3. 最優先を選び、計画を作成
4. 計画に従って実装
5. レビューして Issue をクローズ

### スケーリングの考慮事項

Plan Stack はコードベースのサイズに応じてスケールします。

| 懸念事項 | 解決策 |
|---------|----------|
| 1000以上の計画ファイル | ファイルシステム構成、grep で検索 |
| 大規模チーム | ドメインベースの計画所有権 |
| 複数リポジトリ | リポジトリ間の計画参照 |

---

## 関連

- [Getting Started](../getting-started.md)
- [アーキテクチャ](architecture.md)
- [テンプレート](../templates/)
