# はじめに

プロジェクトに Plan Stack を導入するためのステップバイステップガイドです。

## なぜ Plan Stack か？

**問題:**

- ドキュメントが古くなる、または書かれない
- チームメンバーが離れると知識が失われる
- AI コーディングアシスタントは毎回ゼロから始まる
- コードレビューに元の意図のコンテキストがない

**解決策:**

Plan Stack は、実装計画が蓄積・参照・レビューされる自己強化型の知識ループを作ります。新しいタスクは過去の知識の上に構築されます。

```
調査 → 計画 → 実装 → レビュー → （繰り返し）
```

**主要な原則:**

1. **常に 調査 → 計画 → 実装 の流れに従う** — 計画フェーズをスキップしない
2. **Claude Code のプランモード出力を markdown として保存** — 計画は永続的な成果物になる
3. **プルリクエストに計画を含める** — PR にはコードとその背後にある理由の両方が含まれる
4. **自動レビューが計画を参照** — Claude GitHub Actions が実装と意図を比較
5. **時間とともに計画を積み重ねる** — 各計画は過去の計画を参照し、組織知識を構築
6. **計画はセーブポイント** — コンテキストウィンドウは埋まる。保存された計画があれば `/clear` して「計画を読んで続けて」で復元できる

**なぜ機能するのか:**

- コーディング前にアプローチを合意することで、AI アシスト開発での手戻りを削減
- コードベースの複雑さに応じてスケール — 人間と AI の両方が蓄積されたコンテキストを通じて大規模コードベースをナビゲートできる
- 現代の AI モデルでは計画のコストはほぼゼロ — ドキュメントを書かない理由がなくなった

---

## 1. ディレクトリ構造の作成

プロジェクトルートに以下のディレクトリを作成します：

```bash
mkdir -p docs/plans
mkdir -p docs/templates
```

## 2. テンプレートの追加

以下のテンプレートを `docs/templates/` に配置します：

- `plan-template.md` - 実装計画用テンプレート
- `review-template.md` - レビュー用テンプレート

## 3. CLAUDE.md の設定

プロジェクトの `CLAUDE.md` に以下を追加して Claude Code に指示します：

```markdown
## Plan Stack ワークフロー

機能や修正を実装する前に:
1. docs/plans/ で類似の過去の実装を検索
2. Plan Mode に入る（Claude Code で Shift+Tab を2回）
3. docs/plans/YYYYMMDD_feature_name.md に実装計画を作成
4. コーディング前に人間の承認を得る
5. Plan Mode を終了して実装

実装後:
- AI レビューが計画とコードを比較
- 完了した計画を docs/plans/completed/ に移動
```

## 4. ワークフロー

### ステップ 1: 調査

実装の前に、類似の過去の作業を検索します：

```
docs/plans/ で [あなたの機能] に関連する実装を検索。
```

### ステップ 2: 計画

Claude Code で Plan Mode に入り（`Shift+Tab` を2回）、計画を作成します：

```bash
# 計画ファイルの命名規則
docs/plans/YYYYMMDD_feature_name.md

# 例
docs/plans/20250108_user_authentication.md
docs/plans/20250108_csv_export.md
```

計画に含めるべき内容：
- タスクの概要
- 調査結果（関連する過去の計画、影響を受けるファイル）
- 実装アプローチ
- 修正するファイル

参考として[実際の例](../../examples/plans/)をご覧ください。

**進める前に人間の承認を待ちます。**

### ステップ 3: 実装

Plan Mode を終了し、承認された計画に従って実装します。

### ステップ 4: レビュー

AI が計画と実際の実装を比較します：
- 計画通りに完了したものは何か？
- 何が逸脱（ドリフト）したか、なぜか？
- 将来の計画のための教訓

完了した計画をアーカイブ：
```bash
mv docs/plans/20250108_feature.md docs/plans/completed/
```

## 5. 継続的改善

- 計画を削除しない — 蓄積する
- 類似の機能を実装するときは過去の計画を参照
- レビューの洞察を将来の計画に適用

---

## 既存プロジェクトへの導入

大規模な既存コードベースに Plan Stack を導入する場合、「Plan Stack をやろう」ではなく、問題を見つけることから始めます。

```
監査 → トリアージ → 計画 → 実装 → レビュー
```

1. **監査** — Claude にコードベースを分析させ、問題を特定（技術的負債、パフォーマンス、セキュリティ）
2. **トリアージ** — 発見を GitHub Issue に変換。人間が優先順位付け。
3. **計画** — 最優先の Issue を選び、実装計画を作成
4. **実装** — Opus が計画に従って実装
5. **レビュー** — 計画とコードを比較し、Issue をクローズ

**なぜ機能するのか:**
- 「問題を見つける」は「方法論を導入する」より簡単
- 既に持っている GitHub Issues を使用
- 人間は優先順位付け（本質的な作業）に集中
- 各サイクルで計画が自然に蓄積

---

## オンボーディングのために

**新メンバーがどれだけ早く生産的になるかは、チームにとって最も重要な指標の一つです。**

多くのチームはオンボーディングを偶然に任せています。Plan Stack はそれを第一級の関心事として扱います。

Plan Stack では、新メンバーは計画を書くことで学びます：

1. Claude を使って担当エリアを調査（`docs/` が既存のコンテキストを提供）
2. 小さな修正でも計画を書く
3. シニアがコード前に意図をレビュー
4. 承認後に実装

質問は文書化された回答になります。各計画は将来のメンバーの参考になります。副次的な効果として、シニアエンジニアは同じ説明を繰り返さなくなります — Claude と蓄積されたドキュメントがそれを処理します。

---

## 次のステップ

- [ディレクトリ構造](directory-structure.md)
- [アーキテクチャ](architecture.md)
- [機能](features.md)
- [テンプレート](../templates/)
