# アーキテクチャ

Plan Stack のコアアーキテクチャと原則について説明します。

## 概要

Plan Stack は **Context Engineering（コンテキストエンジニアリング）** の原則に基づいています。これは、開発タスク中に AI モデルが受け取る情報を体系的に管理するアプローチです。

```
┌─────────────────────────────────────────────────────────────┐
│                   Plan Stack ワークフロー                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────┐ │
│   │  調査    │───>│  計画    │───>│  実装    │───>│レビュー│ │
│   └──────────┘    └──────────┘    └──────────┘    └──────┘ │
│        │               │               │              │     │
│        v               v               v              v     │
│   ┌──────────────────────────────────────────────────────┐ │
│   │                   docs/plans/                         │ │
│   │                （蓄積された知識）                        │ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 3つの原則

### 1. Isolation（分離）

**モノリスを丸ごと渡さない。責務でスコープを切る。**

タスクに必要な最小限のコンテキストを提供します。最小の「ファイル」ではなく、最小の「境界づけられたコンテキスト」です。

| 良いコンテキスト | 悪いコンテキスト |
|-------------|-------------|
| 機能に直接関連するファイル | リポジトリ全体 |
| 関連する過去の計画書 | 作成された全ての計画書 |
| 特定の API エンドポイント | 全ての API ドキュメント |

**自問:** *「この特定の問題を解決するために必要な最小限のコンテキストは何か？」*

### 2. Chaining（連鎖）

**履歴ではなく、成果物を渡す。**

作業をステージに分割します。各ステージは、会話全体ではなく、前のステージの「出力」を受け取ります。

```
┌──────────┐    成果物        ┌──────────┐    成果物        ┌──────────┐
│   計画   │ ───────────────> │   実装   │ ───────────────> │  レビュー │
│  フェーズ │   (plan.md)      │  フェーズ │   (コード+計画)  │  フェーズ │
└──────────┘                   └──────────┘                   └──────────┘
     │                              │                              │
     │ 新鮮なコンテキスト            │ 新鮮なコンテキスト            │ 新鮮なコンテキスト
     └──────────────────────────────┴──────────────────────────────┘
```

これにより、シグナル密度が高く保たれ、コンテキストが新鮮に保たれます。

**自問:** *「これを、トランスクリプトではなくサマリーを渡すステージに分解できるか？」*

### 3. Headroom（余裕）

**100%の容量で稼働させない。推論のための余裕を確保する。**

トークン制限は入力と出力の「合計」をカバーします。200K のウィンドウに 195K を詰め込むと、モデルが考える余地がほとんど残りません。

| コンテキスト使用率 | 品質 |
|--------------|---------|
| 75%以下 | 最適な推論スペース |
| 75-90% | 品質低下 |
| 90%以上 | 著しく劣化した出力 |

**自問:** *「モデルが単に応答するだけでなく、考えるための十分なスペースを残しているか？」*

## ワークフローアーキテクチャ

### フェーズ 1: 調査（Research）

新しい作業を始める前に、`docs/plans/` で類似の過去の実装を検索します。

**目的:** 生のコードベースではなく、キュレートされたコンテキストから始める。

### フェーズ 2: 計画（Plan）

構造化された実装計画を生成し、人間の承認を得ます。

**目的:** まだ実装しない—推論に全容量を使用する。

### フェーズ 3: 実行（Execute）

計画をガイドとしてコードを書きます。

**目的:** 会話履歴ではなく、計画という成果物を受け取る。

### フェーズ 4: レビュー（Review）

計画と実装を比較し、ドリフトを検出します。

**目的:** 新鮮なコンテキスト、成果物ベースの評価。

## 第一級の成果物としての計画書

計画書には以下が含まれます：
- 数千行のコードにわたる調査結果
- 複数のアプローチの探索
- 行き止まりとその却下理由
- 数十の小さな決定

すべてが **200〜300行** に圧縮されます。

### なぜ計画書が重要か

| 計画書なし | 計画書あり |
|----------------|-------------|
| 50ファイルを再読する | 1ファイルを読む |
| すべてを再発見する | 意図を理解する |
| 決定をやり直す | 自信を持って修正する |

計画書は **キュレートされたコンテキスト**—人間と AI の両方が確実に消費できるように蒸留された、高価な調査結果です。

## `/clear` パターン

コンテキストはオーバーフローするずっと前に劣化します。

1. アプローチが明確になるまで調査する
2. 計画書を書く
3. コンテキストをクリアする（`/clear`）
4. 計画書から再開する

0% のコンテキストで再開—**最初からやり直すことなく**。

## 統合ポイント

### Git との統合

- 計画書はコードと一緒にコミットされる
- PR には実装と推論の両方が含まれる
- 履歴は決定のコンテキストを保持する

### CI/CD との統合

- 自動レビューが計画とコードを比較する
- ドリフト検出が逸脱をキャッチする
- 計画書が将来の実装に役立つ

### チームワークフローとの統合

- 人間の承認が実装のゲートとなる
- 計画書はオンボーディング資料となる
- 知識は時間とともに蓄積される

---

## 関連

- [Getting Started](getting-started.md)
- [ディレクトリ構造](directory-structure.md)
- [機能](features.md)
